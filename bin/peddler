#!/usr/bin/env node

const { program } = require('commander');
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

program
  .name('peddler')
  .description('Peddler CLI for managing your marketplace scrapers')
  .version('1.0.0');

program
  .command('deploy')
  .description('Deploy Peddler to AWS')
  .option('-s, --stage <stage>', 'deployment stage', 'dev')
  .option('-r, --region <region>', 'AWS region', 'us-east-1')
  .action((options) => {
    console.log(`üöÄ Deploying to ${options.stage} in ${options.region}`);
    try {
      execSync(`./scripts/deploy.sh ${options.stage} ${options.region}`, { stdio: 'inherit' });
    } catch (error) {
      console.error('‚ùå Deployment failed:', error.message);
      process.exit(1);
    }
  });

program
  .command('test')
  .description('Test a scraper')
  .option('-s, --stage <stage>', 'deployment stage', 'dev')
  .option('-i, --id <scraperId>', 'scraper ID to test')
  .action((options) => {
    if (!options.id) {
      console.error('‚ùå Scraper ID is required. Use --id <scraperId>');
      process.exit(1);
    }

    console.log(`üß™ Testing scraper: ${options.id}`);
    try {
      const data = JSON.stringify({ body: JSON.stringify({ scraperId: options.id }) });
      execSync(`serverless invoke -f scraper --stage ${options.stage} --data '${data}'`, { stdio: 'inherit' });
    } catch (error) {
      console.error('‚ùå Test failed:', error.message);
      process.exit(1);
    }
  });

program
  .command('logs')
  .description('View function logs')
  .option('-s, --stage <stage>', 'deployment stage', 'dev')
  .option('-f, --function <function>', 'function name', 'scheduler')
  .option('-t, --tail', 'tail logs')
  .action((options) => {
    console.log(`üìã Viewing logs for ${options.function}`);
    try {
      const cmd = `serverless logs -f ${options.function} --stage ${options.stage}${options.tail ? ' --tail' : ''}`;
      execSync(cmd, { stdio: 'inherit' });
    } catch (error) {
      console.error('‚ùå Failed to retrieve logs:', error.message);
      process.exit(1);
    }
  });

program
  .command('config')
  .description('Manage scraper configuration')
  .option('-s, --stage <stage>', 'deployment stage', 'dev')
  .option('--get', 'get current configuration')
  .option('--set <file>', 'set configuration from file')
  .action((options) => {
    const paramName = `/peddler/${options.stage}/config`;

    if (options.get) {
      console.log(`üìñ Getting configuration from ${paramName}`);
      try {
        const result = execSync(`aws ssm get-parameter --name "${paramName}" --query "Parameter.Value" --output text`, { encoding: 'utf8' });
        console.log(JSON.stringify(JSON.parse(result), null, 2));
      } catch (error) {
        console.error('‚ùå Failed to get configuration:', error.message);
        process.exit(1);
      }
    } else if (options.set) {
      console.log(`üìù Setting configuration from ${options.set}`);
      try {
        if (!fs.existsSync(options.set)) {
          console.error(`‚ùå File not found: ${options.set}`);
          process.exit(1);
        }
        execSync(`aws ssm put-parameter --name "${paramName}" --value file://${options.set} --type String --overwrite`, { stdio: 'inherit' });
        console.log('‚úÖ Configuration updated successfully');
      } catch (error) {
        console.error('‚ùå Failed to set configuration:', error.message);
        process.exit(1);
      }
    } else {
      console.log('Please specify --get or --set <file>');
    }
  });

program
  .command('secrets')
  .description('Manage secrets')
  .option('-s, --stage <stage>', 'deployment stage', 'dev')
  .option('--get', 'get current secrets (masked)')
  .option('--set <file>', 'set secrets from file')
  .action((options) => {
    const secretName = `peddler/${options.stage}/secrets`;

    if (options.get) {
      console.log(`üîê Getting secrets from ${secretName}`);
      try {
        const result = execSync(`aws secretsmanager get-secret-value --secret-id "${secretName}" --query "SecretString" --output text`, { encoding: 'utf8' });
        const secrets = JSON.parse(result);

        // Mask sensitive values
        Object.keys(secrets).forEach(key => {
          if (secrets[key]) {
            secrets[key] = secrets[key].substring(0, 4) + '****';
          }
        });

        console.log(JSON.stringify(secrets, null, 2));
      } catch (error) {
        console.error('‚ùå Failed to get secrets:', error.message);
        process.exit(1);
      }
    } else if (options.set) {
      console.log(`üîê Setting secrets from ${options.set}`);
      try {
        if (!fs.existsSync(options.set)) {
          console.error(`‚ùå File not found: ${options.set}`);
          process.exit(1);
        }
        execSync(`aws secretsmanager update-secret --secret-id "${secretName}" --secret-string file://${options.set}`, { stdio: 'inherit' });
        console.log('‚úÖ Secrets updated successfully');
      } catch (error) {
        console.error('‚ùå Failed to set secrets:', error.message);
        process.exit(1);
      }
    } else {
      console.log('Please specify --get or --set <file>');
    }
  });

program
  .command('status')
  .description('Check deployment status')
  .option('-s, --stage <stage>', 'deployment stage', 'dev')
  .action((options) => {
    console.log(`üìä Checking status for ${options.stage} stage`);
    try {
      console.log('\nüîç Stack info:');
      execSync(`serverless info --stage ${options.stage}`, { stdio: 'inherit' });

      console.log('\nüìã Recent scheduler logs:');
      execSync(`serverless logs -f scheduler --stage ${options.stage} --startTime 5m`, { stdio: 'inherit' });
    } catch (error) {
      console.error('‚ùå Failed to get status:', error.message);
      process.exit(1);
    }
  });

program
  .command('remove')
  .description('Remove deployment from AWS')
  .option('-s, --stage <stage>', 'deployment stage', 'dev')
  .option('--force', 'skip confirmation')
  .action((options) => {
    if (!options.force) {
      console.log(`‚ö†Ô∏è  This will remove the entire ${options.stage} deployment from AWS.`);
      console.log('üí° Use --force to skip this confirmation.');
      console.log('‚ùå Aborted.');
      return;
    }

    console.log(`üóëÔ∏è  Removing ${options.stage} deployment`);
    try {
      execSync(`serverless remove --stage ${options.stage}`, { stdio: 'inherit' });
      console.log('‚úÖ Deployment removed successfully');
    } catch (error) {
      console.error('‚ùå Failed to remove deployment:', error.message);
      process.exit(1);
    }
  });

program.parse();
